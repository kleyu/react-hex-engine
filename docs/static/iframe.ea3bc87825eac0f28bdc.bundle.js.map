{"version":3,"file":"static/iframe.ea3bc87825eac0f28bdc.bundle.js","sources":["webpack:///./src/HexUtils.js"],"sourcesContent":["import Hex from \"./models/Hex\";\r\nimport Point from \"./models/Point\";\r\n\r\nclass HexUtils {\r\n  static DIRECTIONS = [\r\n    new Hex(1, 0),\r\n    new Hex(1, -1),\r\n    new Hex(0, -1),\r\n    new Hex(-1, 0),\r\n    new Hex(-1, 1),\r\n    new Hex(0, 1)\r\n  ];\r\n\r\n  static equals(a, b) {\r\n    return a.q === b.q && a.r === b.r && a.s === b.s;\r\n  }\r\n\r\n  static add(a, b) {\r\n    return new Hex(a.q + b.q, a.r + b.r, a.s + b.s);\r\n  }\r\n\r\n  static subtract(a, b) {\r\n    return new Hex(a.q - b.q, a.r - b.r, a.s - b.s);\r\n  }\r\n\r\n  static multiply(a, k) {\r\n    return new Hex(a.q * k, a.r * k, a.s * k);\r\n  }\r\n\r\n  static lengths(hex) {\r\n    return parseInt((Math.abs(hex.q) + Math.abs(hex.r) + Math.abs(hex.s)) / 2);\r\n  }\r\n\r\n  static distance(a, b) {\r\n    return HexUtils.lengths(HexUtils.subtract(a, b));\r\n  }\r\n\r\n  static direction(direction) {\r\n    return HexUtils.DIRECTIONS[(6 + (direction % 6)) % 6];\r\n  }\r\n\r\n  static neighbour(hex, direction) {\r\n    return HexUtils.add(hex, HexUtils.direction(direction));\r\n  }\r\n\r\n  static neighbours(hex) {\r\n    const array = [];\r\n    for (let i = 0; i < HexUtils.DIRECTIONS.length; i += 1) {\r\n      array.push(HexUtils.neighbour(hex, i));\r\n    }\r\n\r\n    return array;\r\n  }\r\n\r\n  static round(hex) {\r\n    let rq = Math.round(hex.q);\r\n    let rr = Math.round(hex.r);\r\n    let rs = Math.round(hex.s);\r\n\r\n    const qDiff = Math.abs(rq - hex.q);\r\n    const rDiff = Math.abs(rr - hex.r);\r\n    const sDiff = Math.abs(rs - hex.s);\r\n\r\n    if (qDiff > rDiff && qDiff > sDiff) rq = -rr - rs;\r\n    else if (rDiff > sDiff) rr = -rq - rs;\r\n    else rs = -rq - rr;\r\n\r\n    return new Hex(rq, rr, rs);\r\n  }\r\n\r\n  static hexToPixel(hex, layout) {\r\n    const s = layout.spacing;\r\n    const M = layout.orientation;\r\n    let x = (M.f0 * hex.q + M.f1 * hex.r) * layout.size.x;\r\n    let y = (M.f2 * hex.q + M.f3 * hex.r) * layout.size.y;\r\n    // Apply spacing\r\n    x = x * s;\r\n    y = y * s;\r\n    return new Point(x + layout.origin.x, y + layout.origin.y);\r\n  }\r\n\r\n  static pixelToHex(point, layout) {\r\n    const M = layout.orientation;\r\n    const pt = new Point(\r\n      (point.x - layout.origin.x) / layout.size.x,\r\n      (point.y - layout.origin.y) / layout.size.y\r\n    );\r\n    const q = M.b0 * pt.x + M.b1 * pt.y;\r\n    const r = M.b2 * pt.x + M.b3 * pt.y;\r\n    const hex = new Hex(q, r, -q - r);\r\n    return HexUtils.round(hex);\r\n  }\r\n\r\n  static lerp(a, b, t) {\r\n    return a + (b - a) * t;\r\n  }\r\n\r\n  static hexLerp(a, b, t) {\r\n    return new Hex(\r\n      HexUtils.lerp(a.q, b.q, t),\r\n      HexUtils.lerp(a.r, b.r, t),\r\n      HexUtils.lerp(a.s, b.s, t)\r\n    );\r\n  }\r\n\r\n  static getID(hex) {\r\n    if (hex instanceof Hex) {\r\n      return hex.toString();\r\n    }\r\n    return `${hex.q},${hex.r},${hex.s}`;\r\n  }\r\n}\r\n\r\nexport default HexUtils;\r\n"],"mappings":"AAGA","sourceRoot":""}